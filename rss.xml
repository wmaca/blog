<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[walter macambira]]></title><description><![CDATA[My personal blog]]></description><link>https://blog.macambira.co</link><generator>RSS for Node</generator><lastBuildDate>Fri, 02 Aug 2019 15:46:05 GMT</lastBuildDate><item><title><![CDATA[Managed storage for the browser]]></title><description><![CDATA[Over the last years, web applications went from simple pages - where almost everything was handled by a backend - to increasingly complex…]]></description><link>https://blog.macambira.co/managed-storage-for-the-browser/</link><guid isPermaLink="false">https://blog.macambira.co/managed-storage-for-the-browser/</guid><pubDate>Thu, 18 Jul 2019 17:12:03 GMT</pubDate><content:encoded>&lt;p&gt;Over the last years, web applications went from simple pages - where almost everything was handled by a backend - to increasingly complex pieces of software, even capable of running in the absence of internet connectivity. Backend’s responsibilities were reduced, in some cases, to only serve static assets.&lt;/p&gt;
&lt;p&gt;To enable this evolution, applications started to require a way to store assets and other data locally. And, for this, a wide variety of mechanisms were made available, trying always to address the evolving needs of web development. Naturally, new use cases are constantly appearing, in a faster pace than standards could anticipate.&lt;/p&gt;
&lt;p&gt;This writing will try to address one of those use cases that is still not fully addressed: a &lt;em&gt;managed storage solution&lt;/em&gt;. This solution provides, to a browser-based application, a &lt;strong&gt;secure&lt;/strong&gt; and &lt;strong&gt;controlled&lt;/strong&gt; way to locally persist assets and other forms of data. These emphasised properties are the key of such solution, and will be discussed in detail.&lt;/p&gt;
&lt;p&gt;During this document, the current available storage mechanisms and their limitations are discussed. With the knowledge acquired, it is shown how they can be used to build a managed storage solution.&lt;/p&gt;
&lt;p&gt;In the end of this reading, you are expected to have a better understating of what the browser can and can’t do when it comes to storage, and to know how careful you need to be when dealing with this.&lt;/p&gt;
&lt;h2&gt;Available browser APIs&lt;/h2&gt;
&lt;p&gt;Currently, browsers offer a few storage mechanisms, each with a different purpose:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cookies&lt;/li&gt;
&lt;li&gt;Web Storage API (&lt;code class=&quot;language-text&quot;&gt;localStorage&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Application Cache&lt;/li&gt;
&lt;li&gt;IndexedDB&lt;/li&gt;
&lt;li&gt;File API and File and Directory Entries API&lt;/li&gt;
&lt;li&gt;Cache API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some of them have their usage deprecated (e.g. Application Cache), others have serious constraints, like reduced size limit and data type (e.g. Web Storage API, Cookies), which would make them unusable for a more complex storage management solution. File API, and File and Directory Entries API are not a standard yet.&lt;/p&gt;
&lt;p&gt;For those not familiar with &lt;strong&gt;IndexedDB&lt;/strong&gt; , it “&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;is a low-level API for client-side storage of significant amounts of structured data, including files/blobs&lt;/a&gt;”. The interesting part is that it has indexes, allowing performant searches in the data stored. It’s API is event based, and it takes some time to get familiarised with it.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Cache API&lt;/strong&gt; is part of the Service Workers specification, but there is no need for them to be used together. It is basically a &lt;code class=&quot;language-text&quot;&gt;Request&lt;/code&gt; / &lt;code class=&quot;language-text&quot;&gt;Response&lt;/code&gt; storage, where you can create different caches for different purposes (e.g. a cache for offline assets and another for content-related images). It has a Promise based API .&lt;/p&gt;
&lt;p&gt;Both are accessible from window, service workers and web workers, making them more versatile for a proper storage solution. For example, requests can be intercepted at the service workers and stored, and heavy activities, such as cleaning expired stored items, can be offloaded to a web worker.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IndexedDB&lt;/strong&gt; and &lt;strong&gt;Cache API&lt;/strong&gt; are the few left options, and, as explained later, will both be used for different parts of the managed store solution.&lt;/p&gt;
&lt;h2&gt;Purpose of the each API&lt;/h2&gt;
&lt;p&gt;As &lt;strong&gt;Cache API&lt;/strong&gt; is &lt;code class=&quot;language-text&quot;&gt;Request&lt;/code&gt;/&lt;code class=&quot;language-text&quot;&gt;Response&lt;/code&gt; based, it is natural to choose it as the mechanism to store assets, like images, JS/CSS files and templates. It is tempting to extend this rationale and consider using this API to store raw responses from external services consumed by the application.&lt;/p&gt;
&lt;p&gt;Nevertheless, those responses, in general, are only valuable after being parsed, which can expensive to perform on every access to the data. In addition, most of the times, only small parts of the responses are relevant. Not to say that a &lt;code class=&quot;language-text&quot;&gt;Response&lt;/code&gt; instance would also contain headers and other information, which are likely to become useless for the application after its parse.&lt;/p&gt;
&lt;p&gt;For &lt;strong&gt;IndexedDB&lt;/strong&gt; is left the other range of data, which, as explained before, is not suitable to be stored as a &lt;code class=&quot;language-text&quot;&gt;Response&lt;/code&gt;. It can be used not only to the data itself, but also to keep record of metadata, necessary to the management of storage. As will be shown later, when under pressure, it is necessary to know &lt;strong&gt;what&lt;/strong&gt; to delete, and to know &lt;strong&gt;where&lt;/strong&gt; it is actually stored.&lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;While different use cases may appear when exercising a way to properly manage stored information, the following requirements presented themselves as the already-hard-to-meet minimum set of requirements.&lt;/p&gt;
&lt;h3&gt;Priority&lt;/h3&gt;
&lt;p&gt;A stored item may be defined as &lt;strong&gt;persistent&lt;/strong&gt;. In this case, there is no situation where it can be removed from the storage. All other items are called &lt;strong&gt;best-effort&lt;/strong&gt;, which means that they will reside in the storage as long as possible.&lt;/p&gt;
&lt;h3&gt;Expiration&lt;/h3&gt;
&lt;p&gt;Information that is outdated must expire. It can no longer live in the storage, as it is deemed invalid, making its usage harmful to the proper functioning of an application.&lt;/p&gt;
&lt;h3&gt;Pressure&lt;/h3&gt;
&lt;p&gt;Storage is a finite resource, therefore it is necessary to know how much is being consumed, and how much is still available. When a certain limit is reached, the storage manager must act upon it, and free the space to ensure things will keep working.&lt;/p&gt;
&lt;h3&gt;ACID&lt;/h3&gt;
&lt;p&gt;Borrowing this acronym from database systems, and probably oversimplifying it, our storage operations must:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;be either complete or incomplete (&lt;strong&gt;atomicity&lt;/strong&gt;), there is no middle ground;&lt;/li&gt;
&lt;li&gt;take the storage management from one to another valid state (&lt;strong&gt;consistency&lt;/strong&gt;);&lt;/li&gt;
&lt;li&gt;allow usage from simultaneous clients without any unknown risks (&lt;strong&gt;isolation&lt;/strong&gt;); and&lt;/li&gt;
&lt;li&gt;be persistent, once completed, surviving to crashes and unexpected problems (&lt;strong&gt;durability&lt;/strong&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Versioning&lt;/h3&gt;
&lt;p&gt;An information or an asset is generally only valid to a specific point in time, which can be translated to a version of an application. When the application version changes, the store content may become useless.&lt;/p&gt;
&lt;h2&gt;Requirements versus Reality&lt;/h2&gt;
&lt;p&gt;Requirements always look nice in paper, but reality may be shocking. Sometimes, it is not about the will, but the tools available to have a job done. As discussed earlier, &lt;strong&gt;Cache API&lt;/strong&gt; and &lt;strong&gt;IndexedDB&lt;/strong&gt; are the tools available, and their limitation must be taken into account.&lt;/p&gt;
&lt;h3&gt;Priority, but only if the user wants to.&lt;/h3&gt;
&lt;p&gt;Browsers allow the data to be stored in two different modes: &lt;strong&gt;best-effort&lt;/strong&gt; and &lt;strong&gt;persistent&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;With &lt;strong&gt;best-effort&lt;/strong&gt; mode, data will be removed automatically whenever the browser judges necessary, and without requesting any action from the user. There is no guarantee that stored information won’t be removed by the browser.&lt;/p&gt;
&lt;p&gt;With &lt;strong&gt;persistent&lt;/strong&gt; mode, the user must directly instruct the browser to remove the data. Under storage pressure scenarios (i.e. browser running out of space for the application), the user must manually take action to free storage, given an alert from the browser. It is needlessly to say that the application itself can also delete the stored content. When an application relies on this type of storage, it must be taken into consideration by the application developers that the user may delete the stored information accidentally, and there is no way the application can warn or interfere during this process.&lt;/p&gt;
&lt;p&gt;Persistent storage creates the need of an API not only to check if it is permitted, but also to request permission for persistent storage to the user:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isPersistent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;persisted&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;isPersistent&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// actually prompt the user for persistence with the browser UI&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; persistenceAllowed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;persist&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;persistenceAllowed&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// warn the user about potential reduced functionalities&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code above &lt;em&gt;may not be the optimal user experience&lt;/em&gt;, as it may result in an unannounced browser prompt, which may lead to user confusion. Application developers should act exactly as &lt;code class=&quot;language-text&quot;&gt;persist()&lt;/code&gt; does, checking if the &lt;code class=&quot;language-text&quot;&gt;&amp;quot;persistent-storage&amp;quot;&lt;/code&gt; permission is &lt;code class=&quot;language-text&quot;&gt;&amp;quot;granted&amp;quot;&lt;/code&gt; — using &lt;code class=&quot;language-text&quot;&gt;navigator.permissions.query()&lt;/code&gt;. This way the user can receive prior clarification about the request for persistent storage that is about to happen.&lt;/p&gt;
&lt;p&gt;The browser may decide to grant an application the right to persist storage without directly asking the user for it. Or it may not even prompt the user to ask for persistent storage when instructed to (.e.g. opaque origin, or already knows the current permission state). For the former, each browser seems to have its own criteria, so do not wonder if &lt;code class=&quot;language-text&quot;&gt;isPersistent&lt;/code&gt; being &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; on the first run of this snippet.&lt;/p&gt;
&lt;p&gt;As probably already noticed, given the API presented, persistence is not fine-grained. Either everything is persistent, or nothing is. But what is &lt;em&gt;everything&lt;/em&gt;? For site storage, which includes Cache API and IndexedDB, &lt;em&gt;each origin&lt;/em&gt; has &lt;em&gt;one&lt;/em&gt; site storage unit. &lt;em&gt;Each of these units contains a single bucket&lt;/em&gt;. And the explained-above persistence mode &lt;em&gt;is applied to the whole bucket&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To make things worse, buckets are atomic units. When deleted, they must be deleted in its entirety. For a &lt;strong&gt;best-effort&lt;/strong&gt; bucket under storage pressure, this means loosing all stored information, and not only the necessary bits.&lt;/p&gt;
&lt;p&gt;If bucket modes could be applied in a more fine-grained fashion, a storage management solution would take advantage of those built-in capabilities. As this is not the case, &lt;strong&gt;persistent&lt;/strong&gt; mode is the only viable option for a storage manager, as leaving it to best-effort would possibly lead to an unexpected loss of all data.&lt;/p&gt;
&lt;h3&gt;Pressure: I will let you know if you ask me&lt;/h3&gt;
&lt;p&gt;As, by choosing &lt;strong&gt;persistent&lt;/strong&gt; mode, there is no built-in eviction in place, a storage management solution must be responsible to control the usage of free space. Fortunately, browsers provide &lt;code class=&quot;language-text&quot;&gt;navigator.storage.estimate()&lt;/code&gt;, which allows an application to retrieve the number of &lt;em&gt;bytes&lt;/em&gt; available to (&lt;code class=&quot;language-text&quot;&gt;quota&lt;/code&gt;) and used by (&lt;code class=&quot;language-text&quot;&gt;usage&lt;/code&gt;) an origin’s site storage unit.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; quota&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; usage &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;storage&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;estimate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Browsers are encouraged to provide a conservative estimation of the quota, as a manner to prevent unexpectedly hitting the real limit. Not only this, this value for each origin may be based on its popularity (e..g bookmarked application).&lt;/p&gt;
&lt;p&gt;It is important to note that those values are not precise. Not only to avoid its usage as a way to fingerprint devices, but also because browsers may optimise how information is stored — as explained below.&lt;/p&gt;
&lt;p&gt;With this estimation, storage usage can be actively monitored to detect when an application is running out of free space. Upon detection, eviction must kick in. The heuristic chosen to evict data can have any desired level of complexity, and must be done in accordance to the reality of the application and targeted devices.&lt;/p&gt;
&lt;p&gt;If the eviction heuristic needs the size of each item individually, it is worth remembering that IndexedDB and Cache API do not provide any API for this. Nevertheless, it is possible to create a pessimistic estimation function, and test it agains the data normally used by the application. Being optimistic may lead to undetected pressure situations, and being too pessimistic may lead to frequent false-positive pressure.&lt;/p&gt;
&lt;p&gt;Estimating the size of data may be tricky, as storage mechanisms have their own techniques to persist things, which may include metadata. A good example of this is &lt;a href=&quot;https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal&quot;&gt;how IndexedDB serializes its data with its structured clone algorithm&lt;/a&gt;. Not only this, but optimizations, such as deduplication and compression, may make it impractical to properly guess the size occupied by the data.&lt;/p&gt;
&lt;h3&gt;Expiration: “exp… what?”&lt;/h3&gt;
&lt;p&gt;Until this point, the eviction policy has been presented as a form to protect an application from using the storage beyond its space capacity. Nevertheless, there are other use cases which would add value to a managed storage solution.&lt;/p&gt;
&lt;p&gt;When storing an item, it would be interesting to be able to set an expiration date, removing the item automatically when it is reached. This could be leveraged, for example, when using the storage solution for caching purposes. However, &lt;strong&gt;IndexedDB&lt;/strong&gt; and &lt;strong&gt;Cache API&lt;/strong&gt; do not provide an API for that. Even when a &lt;code class=&quot;language-text&quot;&gt;Response&lt;/code&gt; has headers defining an expiration, such as &lt;code class=&quot;language-text&quot;&gt;Cache-Control&lt;/code&gt;, &lt;strong&gt;Cache API&lt;/strong&gt; does not take it into consideration.&lt;/p&gt;
&lt;p&gt;To overcome this limitation, a managed storage solution would be required to not only track the expiration date for each item, but also to actively check for and remove expired items. As those two last tasks needs to be periodically performed, an item living in the storage may actually be already expired, but it was not removed because the cleanup did not to have a change to run yet. Ensuring this does not happen requires an expiration check to be performed during the retrieval of an item.&lt;/p&gt;
&lt;h3&gt;ACID&lt;/h3&gt;
&lt;p&gt;As the solution will need to keep metadata about each item in the storage, when issuing an operation for an asset, not only the &lt;strong&gt;Cache API&lt;/strong&gt; operation will need to be done, but also one at &lt;strong&gt;IndexedDB&lt;/strong&gt; for the metadata. If both steps fail or both succeed, consistency won’t be affected. If only the storage itself fails, metadata about an inexistent item may be created. If only the metadata storage fails, a stored item may become invisible to the managed storage solution.&lt;/p&gt;
&lt;p&gt;Regarding those two last cases, the later presents more harm than the former, as it would cause unsupervised usage of storage, which would eventually exhaust. The former can be easily resolved: as the item is being tracked, it can be removed when under pressure or when expired. This, however, may impact the proper function of the application, as it will see an item allegedly using space that could be used for other purpose, while it actually is not.&lt;/p&gt;
&lt;p&gt;Both of the chosen browser APIs do not provide a mechanism that allows to revert the failing step. Thus it is a responsibility of the managed storage solution to ensure that the side effects of an eventual failure are under control.&lt;/p&gt;
&lt;p&gt;As having an item without metadata has more serious implications, the order of operations — storing metadata before actually storing the item — may be enough to sufficiently overcome the lack of consistency guarantee. In case the metadata operation is successful, but it fails to store the item itself, the inconsistency created can be eventually addressed, and its impact may be acceptable for the application. This approach presents as a simpler alternative to actually implementing a consistency mechanism.&lt;/p&gt;
&lt;p&gt;Despite IndexedDB having transactions, it has an auto-commit behaviour, which does not allow async operations that are not related to the transaction to happen during it. One could argue that, as &lt;strong&gt;IndexedDB&lt;/strong&gt; can store blobs, using it instead of &lt;strong&gt;Cache API&lt;/strong&gt; to store assets would resolve this issue. This is a valid approach, which has not been experimented during the writing of this.&lt;/p&gt;
&lt;p&gt;Other problem that arises from having those two interconnected steps is the lack of isolation. During the execution of an operation, while it is incomplete, a different operation may see it partially applied, as it has more than one step. Fortunately, a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API&quot;&gt;web lock&lt;/a&gt; can be request to only allow one operation to happen at any given time. Defining what is to be “locked” and when is crucial, as unnecessary locks may hit performance. More complex solutions were not explored by the time of this writing.&lt;/p&gt;
&lt;p&gt;Again, using &lt;strong&gt;IndexedDB&lt;/strong&gt; to store assets — instead of &lt;strong&gt;Cache API&lt;/strong&gt; — is a possible solution for the lack of isolation, as its transaction mechanism would offer such guarantee.&lt;/p&gt;
&lt;h3&gt;Versioning&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Cache API&lt;/strong&gt; does not have a versioning mechanism, but &lt;strong&gt;IndexedDB&lt;/strong&gt; does. For the later, when opening a database, a version number can be passed as an argument. In case there is a version upgrade — as a downgrade cannot happen — it allows the developer to access the current values stored to properly migrate them to a format compatible with the new version.&lt;/p&gt;
&lt;p&gt;Again, not using &lt;strong&gt;Cache API&lt;/strong&gt; for assets appears as an option. Regardless of which storage is used, deciding how to handle a version upgrade — additions, removals and migrations — may still be cumbersome.&lt;/p&gt;
&lt;p&gt;In case the managed storage solution offers user-defined units of storage (not to be confused with the earlier presented concept of unit), a version can be associated to each of them. During a version upgrade, emptying the unit may be simplest approach to proper handle versioning.&lt;/p&gt;
&lt;p&gt;With the possibility of multiple windows running different versions &lt;em&gt;of the application&lt;/em&gt;, it is important to note that different versions &lt;em&gt;of the storage&lt;/em&gt; may be accessed at the same time. Such a managed storage solution should handle this case, as it may lead to unexpected behaviour of the application.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;As seen, despite providing valuable functionalities to applications in general, the currently available storage APIs still don’t suffice for the use case presented. Lack of control over each item expiration and a global eviction policy impose challenges to more complex applications. Features like IndexedDB’s auto-commit, while may benefit other more frequent use cases, create serious limitations. Not only this, but the overlap of functionalities, as IndexedDB’s capacity to also store assets, may cause confusion.&lt;/p&gt;
&lt;p&gt;This is intrinsically related to how web development has been evolving over the last years. Its usage went from simple websites, with limited interaction, to complete applications running in the most diverse types of devices. New use cases arise every day, creating problems that the current solutions cannot properly address. This leaves the community — those creating and evolving the standards — with the challenge to balance all the forces in play — keep old things working and embrace the new reality.&lt;/p&gt;
&lt;p&gt;Hopefully, this writing was able to provide an overview of the current state of storage on the web, as well as how to implement a proper managed storage solution.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Sweden, my wife and new life]]></title><description><![CDATA[Finally got some time to start this new thing.I am quite unsure about the content I will upload here. Surely, it will be a tech blog, not a…]]></description><link>https://blog.macambira.co/sweden/</link><guid isPermaLink="false">https://blog.macambira.co/sweden/</guid><pubDate>Sun, 06 Jan 2019 19:56:03 GMT</pubDate><content:encoded>&lt;p&gt;Finally got some time to start this new thing.&lt;/p&gt;
&lt;p&gt;I am quite unsure about the content I will upload here. Surely, it will be a tech blog, not a personal one. Soon, I think I will figure out what to talk about. For now, read about our first week in Sweden.&lt;/p&gt;
&lt;h2&gt;Arrival&lt;/h2&gt;
&lt;p&gt;Our flight was terrible, with more than 3 hours of delay. Naturally, after more than 20 hours from our departure, we were starving, and morale was down. Thankfully, our friends picked us up in the airport. It would be a nightmare to carry 92kg of luggage around, below zero degrees Celsius.&lt;/p&gt;
&lt;p&gt;After getting the keys of our apartment, we found a pizza place a block away from home. We headed there to make our first unsupervised contact with the swedes, and ended up ordering 3 of what the attendent said to be an “individual pizza”. We still had pizza in the fridge 5 days latter.&lt;/p&gt;
&lt;p&gt;No appointments in the following day: let’s get to sleep.&lt;/p&gt;
&lt;h2&gt;First day&lt;/h2&gt;
&lt;p&gt;We wake up without any idea of what time it is. At this time of the year, the sun rises around 8h30, and sets 15h30. And most days, at least for now, the sun does not seem to really rise: the sky becomes slightly gray and, a few hours later, it is night.&lt;/p&gt;
&lt;p&gt;Well, it is time to find out a little more about the basics of life here.&lt;/p&gt;
&lt;p&gt;We are not in our permanent home, so there is a 15-minute walk between us and &lt;del&gt;civilization&lt;/del&gt; city center. It is cold outside, but let’s keep a positive attitude. Is all about how you face the obstacles life puts in front of you!&lt;/p&gt;
&lt;p&gt;First hours, and we noticed my wife got sick, mainly because of the dry air. Now my job is to keep the morale high for two!&lt;/p&gt;
&lt;p&gt;But, hey! Forget the sad parts. Things get better.&lt;/p&gt;
&lt;p&gt;We knew already a few things: how to get to the city center by foot and the location of the closest grocery store.&lt;/p&gt;
&lt;h2&gt;Climate&lt;/h2&gt;
&lt;p&gt;In São Paulo, it was 20 degrees Celsius. As I worked in Rio de Janeiro, I could still experience something around 40 degrees on my visits to the office. That… is… not.. pleasent at all.&lt;/p&gt;
&lt;p&gt;In Sweden, it is around zero. I thought it would be worse, but it is not. With enough clothes on, it is not the end of the world. Easy to get used to. There are problems, though:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wind is not a friend and may harm you; and&lt;/li&gt;
&lt;li&gt;too many clothes to put on (even to throw the gargabe out is a complicated process of putting too many layers on).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Continues…&lt;/h2&gt;
&lt;p&gt;For my first blog post, I think it is okay for now. But I have a lot to share. There will be some more useful advice here in the following days.&lt;/p&gt;</content:encoded></item></channel></rss>